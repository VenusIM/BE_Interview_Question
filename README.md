# BE_Interview_Question

## Java
- **OOP** <br/> 현실세계를 시스템에 의존적으로 표현하는 방법론으로, 추상화 상속 다형성 캡슐화의 특징이 있어 코드의 재사용성과 유지보수에 용이하다는 장점이 있습니다.

- **객체지향 설계 5가지 원칙** <br/> 
  - 단일책임의 원칙 : 하나의 클래스는 하나의 책임만 가져야한다.
  - 개방/패쇄의 원칙 : 확장에 대해 열려있고 수정에 대해서는 닫혀있어야 한다는 원칙으로 추상화에 의존해야 한다.
  - 리스코프 치환 원칙 : 하위 타입은 상위 타입을 대체할 수 있어야 한다는 원칙이다.
  - 인터페이스 분리 원칙 : 목적과 관심이 각기 다르다면 인터페이스를 통해 적절하게 분리해야 한다.
  - 의존관계 역전 원칙 : 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 되며, 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.

- **AOP** <br/> Aspect Oriented Programming으로 관점 지향 프로그래밍입니다. 핵심적인 기능과 부가적인 기능을 Aspect라는 모듈로서 분리하여 설계하는 방법론이자 OOP를 보조하는 방법론입니다. 많은 중복 코드를 발생시키는 인프라 로직으로 권한 체크, 트렌젝션, 로깅, 성능 측정 등을 비지니스 로직으로 부터 분리하여 재사용성, 유지보수가 좋아집니다.

- **Class, Object, Instance** <br/> 
  - Class란 Object를 정의하고 만들어 내기 위한 설계도이며, Object를 만들어 내기 위해 필요한 변수와 메서드들이 존재합니다.
  - Object란 소프트웨어 세계에 구현할 대상이자 클래스의 인스턴스입니다.
  - Instance란 설계도를 바탕으로 구현된 구체적인 실체로 메모리에 할당됩니다.

- **Interface, Abstract** <br/> 모두 Instance화가 불가하며 추상메서드 구현을 강제합니다. Interface는 다중상속을 지원하며 다른 조상 클래스를 상속하더라도 같은 기능이 필요할 경우 사용하고 클래스와 별도로 구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. Abstract의 경우 단일 상속만을 지원하며 상속할 각 객체들의 공통적인 특성을 찾아 추상화 시켜 놓은 것으로 부모 클래스를 상속하며 부모 클래스가 가진 기능을 구현해야 할 경우에 사용합니다. 

- **Enum** <br/> 열거형이라고 불리며 서로 연관된 상수들의 집합입니다. 코드가 단순해지며 가독성이 좋아지고 타입의 안정성이 보장됩니다.

- **Access Modifier, 사용하는 이유** <br/>

- **Collaction** <br/>

- **Array, LinkedList** <br/>

- **Array, Map** <br/>

- **StringBuilder, StringBuffer** <br/>

## Web

- **IOC** <br/>

- **DI** <br/>

- **DI 방식과 선호하는 방식과 이유**

- **REST** <br/> REST는 자원, 행위, 표현으로 구성된 API 아키텍쳐이다. URI를 통해서 자원을 명시하고, POST, GET, PUT, PATCH 등의 Method를 통해 자원의 행위를 지정합니다. 코드의 재사용성을 높일 수 있고, 프론트와 백엔드의 완전한 분업이 가능해진다는 장점이 있습니다.

- **SpringBoot** <br/>

- **Spring WebFlux** <br/>

- **JPA** <br/>

- **Mybatis** <br/>
  
- **CI/CD** <br/> CI는 개발자를 위한 지속적인 통합, 빌드/테스트 자동화 과정을 의미하며 커밋할 때마다 빌드와 일련의 자동 테스트가 이루어져 동작을 확인하고 변경으로 인한 문제가 생기는 부분이 없도록 보장합니다. CD는 지속적인 서비스 제공 및 배포, 배포 자동화 과정을 의미하며 간단한 코드 변경이 정기적으로 마스터 브랜치에 커밋되고 자동화 된 빌드 및 테스트 프로세스를 거쳐 . 개발 단계를 자동화하여 짧은 주기로 고객에게 제공하는 방법입니다.

- **Junit을 사용한 이유와 적용했던 사례** <br/>

- **Debugging** <br/>

- **SocketJS, STOMP** <br/>

- **WebRTC** <br/>

- **DataTables** <br/>

## CS / Algorithm

- **Process, Thread** <br/>

- **Multi-Process, Multi-Thread** <br/>

- **Stack** <br/>

- **Queue, Heap** <br/>

- **BackTracking** <br/> 모든 경우의 수를 탐색하는 방법, 완전탐색의 아이디어에서 불필요한 분기를 가지치기하는 알고리즘이다. 해가 아니면 돌아가서(Back) 다시 추적하는(Track) 기법을 의미합니다.


## DB & SQL

- **정규화**

- **Index** <br/>

- **Transaction** <br/>

- **InnerJoin, OuterJoin** <br/> INNER JOIN은 키 값이 있는 테이블의 컬럼 값을 비교 후 조건에 맞는 값을 가져오는 조인 방법입니다. Outer Join은 조인하는 여러 테이블에서 한 쪽에는 데이터가 있고 한 쪽에는 데이터가 없는 경우, 데이터가 있는 쪽 테이블의 내용을 전부 출력하는 조인 방법입니다.

## DevOps

- **Git, Github**

- **GitLab**

## 네트워크

- **TCP/UDP**

- **Google.com**

- **OSI 7계층** <br/> 물리, 데이터 링크, 네트워크, 전송, 세션, 표현, 응용

## 이외의 질문
1. Infra 구조는 직접 설계했는지
2. 디버깅 툴은 무얼 사용했는지
3. 프로젝트에서 맡은 파트는 무엇인가요?
11. 기능 구현에 사용한 기술
16. 가장 기억에 남는 알고리즘
17. 혼자서 프로젝트 개발이 가능한가요? 선배의 도움이 필요한가요?
18. DevOps에 관심이 있나요?
21. 사용 전 후의 장단점과 더 흥미로웠던 부분
22. 현업은 너가 하던 알고리즘과 코딩과는 거리가 멀수 도 있는데 어떻게 생각하는가?
23. 통신과를 전공하셨던데 관련이 있는 부분이 있나요?
25. 프론트와 백엔드의 차이와 더 흥미로운 직무는 무엇인가요?
26. 회사에 대해 궁금한점
27. 사옥 이전하는건 아는가요?
28. 데모 버전으로 배포 진행 하셨던데 실제로 서비스를 운영해본적 없나요?
32. 프로그래머스에서 SQL문제를 풀어본적은 없나요?
39. 전체 프로젝트를 진행하면서 어려웠던 부분 어떻게 해결했는지
40. 주량
41. 통근거리
46. 재귀가 무엇인지 아나요?
47. 재귀에서 조심해야 하는 부분
49. 기술을 습득할 때 어떤식으로 습득하나요?
50. 무선통신에 대해
51. 학교에서 협업을 통해 배운게 있나요?
52. ERD 직접 그린것인가?
53. 경매 파트 연관 관계에 대해 설명해보세요.
54. 경매 로직을 직접 짜셨나요? 그렇다면 구현 방식을 설명해주세요.
55. 스케쥴러를 사용하셨던데 사용한 이유를 설명해 주세요.
